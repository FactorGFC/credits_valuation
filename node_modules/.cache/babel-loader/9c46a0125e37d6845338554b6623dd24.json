{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n// I18n.js\n// =======\n//\n// This small library provides the Rails I18n API on the Javascript.\n// You don't actually have to use Rails (or even Ruby) to use I18n.js.\n// Just make sure you export all translations in an object like this:\n//\n//     I18n.translations.en = {\n//       hello: \"Hello World\"\n//     };\n//\n// See tests for specific formatting like numbers and dates.\n//\n// Using UMD pattern from\n// https://github.com/umdjs/umd#regular-module\n// `returnExports.js` version\n;\n\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(\"i18n\", function () {\n      return factory(root);\n    });\n  } else if ((typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) === 'object' && module.exports) {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory(root);\n  } else {\n    // Browser globals (root is window)\n    root.I18n = factory(root);\n  }\n})(this, function (global) {\n  \"use strict\"; // Use previously defined object if exists in current scope\n\n  var I18n = global && global.I18n || {}; // Just cache the Array#slice function.\n\n  var slice = Array.prototype.slice; // Apply number padding.\n\n  var padding = function padding(number) {\n    return (\"0\" + number.toString()).substr(-2);\n  }; // Improved toFixed number rounding function with support for unprecise floating points\n  // JavaScript's standard toFixed function does not round certain numbers correctly (for example 0.105 with precision 2).\n\n\n  var toFixed = function toFixed(number, precision) {\n    return decimalAdjust('round', number, -precision).toFixed(precision);\n  }; // Is a given variable an object?\n  // Borrowed from Underscore.js\n\n\n  var isObject = function isObject(obj) {\n    var type = _typeof(obj);\n\n    return type === 'function' || type === 'object';\n  };\n\n  var isFunction = function isFunction(func) {\n    var type = _typeof(func);\n\n    return type === 'function';\n  }; // Check if value is different than undefined and null;\n\n\n  var isSet = function isSet(value) {\n    return typeof value !== 'undefined' && value !== null;\n  }; // Is a given value an array?\n  // Borrowed from Underscore.js\n\n\n  var isArray = function isArray(val) {\n    if (Array.isArray) {\n      return Array.isArray(val);\n    }\n\n    return Object.prototype.toString.call(val) === '[object Array]';\n  };\n\n  var isString = function isString(val) {\n    return typeof val === 'string' || Object.prototype.toString.call(val) === '[object String]';\n  };\n\n  var isNumber = function isNumber(val) {\n    return typeof val === 'number' || Object.prototype.toString.call(val) === '[object Number]';\n  };\n\n  var isBoolean = function isBoolean(val) {\n    return val === true || val === false;\n  };\n\n  var isNull = function isNull(val) {\n    return val === null;\n  };\n\n  var decimalAdjust = function decimalAdjust(type, value, exp) {\n    // If the exp is undefined or zero...\n    if (typeof exp === 'undefined' || +exp === 0) {\n      return Math[type](value);\n    }\n\n    value = +value;\n    exp = +exp; // If the value is not a number or the exp is not an integer...\n\n    if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) {\n      return NaN;\n    } // Shift\n\n\n    value = value.toString().split('e');\n    value = Math[type](+(value[0] + 'e' + (value[1] ? +value[1] - exp : -exp))); // Shift back\n\n    value = value.toString().split('e');\n    return +(value[0] + 'e' + (value[1] ? +value[1] + exp : exp));\n  };\n\n  var lazyEvaluate = function lazyEvaluate(message, scope) {\n    if (isFunction(message)) {\n      return message(scope);\n    } else {\n      return message;\n    }\n  };\n\n  var merge = function merge(dest, obj) {\n    var key, value;\n\n    for (key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        value = obj[key];\n\n        if (isString(value) || isNumber(value) || isBoolean(value) || isArray(value) || isNull(value)) {\n          dest[key] = value;\n        } else {\n          if (dest[key] == null) dest[key] = {};\n          merge(dest[key], value);\n        }\n      }\n    }\n\n    return dest;\n  }; // Set default days/months translations.\n\n\n  var DATE = {\n    day_names: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n    abbr_day_names: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n    month_names: [null, \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n    abbr_month_names: [null, \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"],\n    meridian: [\"AM\", \"PM\"]\n  }; // Set default number format.\n\n  var NUMBER_FORMAT = {\n    precision: 3,\n    separator: \".\",\n    delimiter: \",\",\n    strip_insignificant_zeros: false\n  }; // Set default currency format.\n\n  var CURRENCY_FORMAT = {\n    unit: \"$\",\n    precision: 2,\n    format: \"%u%n\",\n    sign_first: true,\n    delimiter: \",\",\n    separator: \".\"\n  }; // Set default percentage format.\n\n  var PERCENTAGE_FORMAT = {\n    unit: \"%\",\n    precision: 3,\n    format: \"%n%u\",\n    separator: \".\",\n    delimiter: \"\"\n  }; // Set default size units.\n\n  var SIZE_UNITS = [null, \"kb\", \"mb\", \"gb\", \"tb\"]; // Other default options\n\n  var DEFAULT_OPTIONS = {\n    // Set default locale. This locale will be used when fallback is enabled and\n    // the translation doesn't exist in a particular locale.\n    defaultLocale: \"en\" // Set the current locale to `en`.\n    ,\n    locale: \"en\" // Set the translation key separator.\n    ,\n    defaultSeparator: \".\" // Set the placeholder format. Accepts `{{placeholder}}` and `%{placeholder}`.\n    ,\n    placeholder: /(?:\\{\\{|%\\{)(.*?)(?:\\}\\}?)/gm // Set if engine should fallback to the default locale when a translation\n    // is missing.\n    ,\n    fallbacks: false // Set the default translation object.\n    ,\n    translations: {} // Set missing translation behavior. 'message' will display a message\n    // that the translation is missing, 'guess' will try to guess the string\n    ,\n    missingBehaviour: 'message' // if you use missingBehaviour with 'message', but want to know that the\n    // string is actually missing for testing purposes, you can prefix the\n    // guessed string by setting the value here. By default, no prefix!\n    ,\n    missingTranslationPrefix: ''\n  }; // Set default locale. This locale will be used when fallback is enabled and\n  // the translation doesn't exist in a particular locale.\n\n  I18n.reset = function () {\n    var key;\n\n    for (key in DEFAULT_OPTIONS) {\n      this[key] = DEFAULT_OPTIONS[key];\n    }\n  }; // Much like `reset`, but only assign options if not already assigned\n\n\n  I18n.initializeOptions = function () {\n    var key;\n\n    for (key in DEFAULT_OPTIONS) {\n      if (!isSet(this[key])) {\n        this[key] = DEFAULT_OPTIONS[key];\n      }\n    }\n  };\n\n  I18n.initializeOptions(); // Return a list of all locales that must be tried before returning the\n  // missing translation message. By default, this will consider the inline option,\n  // current locale and fallback locale.\n  //\n  //     I18n.locales.get(\"de-DE\");\n  //     // [\"de-DE\", \"de\", \"en\"]\n  //\n  // You can define custom rules for any locale. Just make sure you return a array\n  // containing all locales.\n  //\n  //     // Default the Wookie locale to English.\n  //     I18n.locales[\"wk\"] = function(locale) {\n  //       return [\"en\"];\n  //     };\n  //\n\n  I18n.locales = {}; // Retrieve locales based on inline locale, current locale or default to\n  // I18n's detection.\n\n  I18n.locales.get = function (locale) {\n    var result = this[locale] || this[I18n.locale] || this[\"default\"];\n\n    if (isFunction(result)) {\n      result = result(locale);\n    }\n\n    if (isArray(result) === false) {\n      result = [result];\n    }\n\n    return result;\n  }; // The default locale list.\n\n\n  I18n.locales[\"default\"] = function (locale) {\n    var locales = [],\n        list = []; // Handle the inline locale option that can be provided to\n    // the `I18n.t` options.\n\n    if (locale) {\n      locales.push(locale);\n    } // Add the current locale to the list.\n\n\n    if (!locale && I18n.locale) {\n      locales.push(I18n.locale);\n    } // Add the default locale if fallback strategy is enabled.\n\n\n    if (I18n.fallbacks && I18n.defaultLocale) {\n      locales.push(I18n.defaultLocale);\n    } // Locale code format 1:\n    // According to RFC4646 (http://www.ietf.org/rfc/rfc4646.txt)\n    // language codes for Traditional Chinese should be `zh-Hant`\n    //\n    // But due to backward compatibility\n    // We use older version of IETF language tag\n    // @see http://www.w3.org/TR/html401/struct/dirlang.html\n    // @see http://en.wikipedia.org/wiki/IETF_language_tag\n    //\n    // Format: `language-code = primary-code ( \"-\" subcode )*`\n    //\n    // primary-code uses ISO639-1\n    // @see http://en.wikipedia.org/wiki/List_of_ISO_639-1_codes\n    // @see http://www.iso.org/iso/home/standards/language_codes.htm\n    //\n    // subcode uses ISO 3166-1 alpha-2\n    // @see http://en.wikipedia.org/wiki/ISO_3166\n    // @see http://www.iso.org/iso/country_codes.htm\n    //\n    // @note\n    //   subcode can be in upper case or lower case\n    //   defining it in upper case is a convention only\n    // Locale code format 2:\n    // Format: `code = primary-code ( \"-\" region-code )*`\n    // primary-code uses ISO 639-1\n    // script-code uses ISO 15924\n    // region-code uses ISO 3166-1 alpha-2\n    // Example: zh-Hant-TW, en-HK, zh-Hant-CN\n    //\n    // It is similar to RFC4646 (or actually the same),\n    // but seems to be limited to language, script, region\n    // Compute each locale with its country code.\n    // So this will return an array containing\n    // `de-DE` and `de`\n    // or\n    // `zh-hans-tw`, `zh-hans`, `zh`\n    // locales.\n\n\n    locales.forEach(function (locale) {\n      var localeParts = locale.split(\"-\");\n      var firstFallback = null;\n      var secondFallback = null;\n\n      if (localeParts.length === 3) {\n        firstFallback = [localeParts[0], localeParts[1]].join(\"-\");\n        secondFallback = localeParts[0];\n      } else if (localeParts.length === 2) {\n        firstFallback = localeParts[0];\n      }\n\n      if (list.indexOf(locale) === -1) {\n        list.push(locale);\n      }\n\n      if (!I18n.fallbacks) {\n        return;\n      }\n\n      [firstFallback, secondFallback].forEach(function (nullableFallbackLocale) {\n        // We don't want null values\n        if (typeof nullableFallbackLocale === \"undefined\") {\n          return;\n        }\n\n        if (nullableFallbackLocale === null) {\n          return;\n        } // We don't want duplicate values\n        //\n        // Comparing with `locale` first is faster than\n        // checking whether value's presence in the list\n\n\n        if (nullableFallbackLocale === locale) {\n          return;\n        }\n\n        if (list.indexOf(nullableFallbackLocale) !== -1) {\n          return;\n        }\n\n        list.push(nullableFallbackLocale);\n      });\n    }); // No locales set? English it is.\n\n    if (!locales.length) {\n      locales.push(\"en\");\n    }\n\n    return list;\n  }; // Hold pluralization rules.\n\n\n  I18n.pluralization = {}; // Return the pluralizer for a specific locale.\n  // If no specify locale is found, then I18n's default will be used.\n\n  I18n.pluralization.get = function (locale) {\n    return this[locale] || this[I18n.locale] || this[\"default\"];\n  }; // The default pluralizer rule.\n  // It detects the `zero`, `one`, and `other` scopes.\n\n\n  I18n.pluralization[\"default\"] = function (count) {\n    switch (count) {\n      case 0:\n        return [\"zero\", \"other\"];\n\n      case 1:\n        return [\"one\"];\n\n      default:\n        return [\"other\"];\n    }\n  }; // Return current locale. If no locale has been set, then\n  // the current locale will be the default locale.\n\n\n  I18n.currentLocale = function () {\n    return this.locale || this.defaultLocale;\n  }; // Check if value is different than undefined and null;\n\n\n  I18n.isSet = isSet; // Find and process the translation using the provided scope and options.\n  // This is used internally by some functions and should not be used as an\n  // public API.\n\n  I18n.lookup = function (scope, options) {\n    options = options || {};\n    var locales = this.locales.get(options.locale).slice(),\n        locale,\n        scopes,\n        fullScope,\n        translations;\n    fullScope = this.getFullScope(scope, options);\n\n    while (locales.length) {\n      locale = locales.shift();\n      scopes = fullScope.split(this.defaultSeparator);\n      translations = this.translations[locale];\n\n      if (!translations) {\n        continue;\n      }\n\n      while (scopes.length) {\n        translations = translations[scopes.shift()];\n\n        if (translations === undefined || translations === null) {\n          break;\n        }\n      }\n\n      if (translations !== undefined && translations !== null) {\n        return translations;\n      }\n    }\n\n    if (isSet(options.defaultValue)) {\n      return lazyEvaluate(options.defaultValue, scope);\n    }\n  }; // lookup pluralization rule key into translations\n\n\n  I18n.pluralizationLookupWithoutFallback = function (count, locale, translations) {\n    var pluralizer = this.pluralization.get(locale),\n        pluralizerKeys = pluralizer(count),\n        pluralizerKey,\n        message;\n\n    if (isObject(translations)) {\n      while (pluralizerKeys.length) {\n        pluralizerKey = pluralizerKeys.shift();\n\n        if (isSet(translations[pluralizerKey])) {\n          message = translations[pluralizerKey];\n          break;\n        }\n      }\n    }\n\n    return message;\n  }; // Lookup dedicated to pluralization\n\n\n  I18n.pluralizationLookup = function (count, scope, options) {\n    options = options || {};\n    var locales = this.locales.get(options.locale).slice(),\n        locale,\n        scopes,\n        translations,\n        message;\n    scope = this.getFullScope(scope, options);\n\n    while (locales.length) {\n      locale = locales.shift();\n      scopes = scope.split(this.defaultSeparator);\n      translations = this.translations[locale];\n\n      if (!translations) {\n        continue;\n      }\n\n      while (scopes.length) {\n        translations = translations[scopes.shift()];\n\n        if (!isObject(translations)) {\n          break;\n        }\n\n        if (scopes.length === 0) {\n          message = this.pluralizationLookupWithoutFallback(count, locale, translations);\n        }\n      }\n\n      if (typeof message !== \"undefined\" && message !== null) {\n        break;\n      }\n    }\n\n    if (typeof message === \"undefined\" || message === null) {\n      if (isSet(options.defaultValue)) {\n        if (isObject(options.defaultValue)) {\n          message = this.pluralizationLookupWithoutFallback(count, options.locale, options.defaultValue);\n        } else {\n          message = options.defaultValue;\n        }\n\n        translations = options.defaultValue;\n      }\n    }\n\n    return {\n      message: message,\n      translations: translations\n    };\n  }; // Rails changed the way the meridian is stored.\n  // It started with `date.meridian` returning an array,\n  // then it switched to `time.am` and `time.pm`.\n  // This function abstracts this difference and returns\n  // the correct meridian or the default value when none is provided.\n\n\n  I18n.meridian = function () {\n    var time = this.lookup(\"time\");\n    var date = this.lookup(\"date\");\n\n    if (time && time.am && time.pm) {\n      return [time.am, time.pm];\n    } else if (date && date.meridian) {\n      return date.meridian;\n    } else {\n      return DATE.meridian;\n    }\n  }; // Merge serveral hash options, checking if value is set before\n  // overwriting any value. The precedence is from left to right.\n  //\n  //     I18n.prepareOptions({name: \"John Doe\"}, {name: \"Mary Doe\", role: \"user\"});\n  //     #=> {name: \"John Doe\", role: \"user\"}\n  //\n\n\n  I18n.prepareOptions = function () {\n    var args = slice.call(arguments),\n        options = {},\n        subject;\n\n    while (args.length) {\n      subject = args.shift();\n\n      if (_typeof(subject) != \"object\") {\n        continue;\n      }\n\n      for (var attr in subject) {\n        if (!subject.hasOwnProperty(attr)) {\n          continue;\n        }\n\n        if (isSet(options[attr])) {\n          continue;\n        }\n\n        options[attr] = subject[attr];\n      }\n    }\n\n    return options;\n  }; // Generate a list of translation options for default fallbacks.\n  // `defaultValue` is also deleted from options as it is returned as part of\n  // the translationOptions array.\n\n\n  I18n.createTranslationOptions = function (scope, options) {\n    var translationOptions = [{\n      scope: scope\n    }]; // Defaults should be an array of hashes containing either\n    // fallback scopes or messages\n\n    if (isSet(options.defaults)) {\n      translationOptions = translationOptions.concat(options.defaults);\n    } // Maintain support for defaultValue. Since it is always a message\n    // insert it in to the translation options as such.\n\n\n    if (isSet(options.defaultValue)) {\n      translationOptions.push({\n        message: options.defaultValue\n      });\n    }\n\n    return translationOptions;\n  }; // Translate the given scope with the provided options.\n\n\n  I18n.translate = function (scope, options) {\n    options = options || {};\n    var translationOptions = this.createTranslationOptions(scope, options);\n    var translation;\n    var usedScope = scope;\n    var optionsWithoutDefault = this.prepareOptions(options);\n    delete optionsWithoutDefault.defaultValue; // Iterate through the translation options until a translation\n    // or message is found.\n\n    var translationFound = translationOptions.some(function (translationOption) {\n      if (isSet(translationOption.scope)) {\n        usedScope = translationOption.scope;\n        translation = this.lookup(usedScope, optionsWithoutDefault);\n      } else if (isSet(translationOption.message)) {\n        translation = lazyEvaluate(translationOption.message, scope);\n      }\n\n      if (translation !== undefined && translation !== null) {\n        return true;\n      }\n    }, this);\n\n    if (!translationFound) {\n      return this.missingTranslation(scope, options);\n    }\n\n    if (typeof translation === \"string\") {\n      translation = this.interpolate(translation, options);\n    } else if (isArray(translation)) {\n      translation = translation.map(function (t) {\n        return typeof t === \"string\" ? this.interpolate(t, options) : t;\n      }, this);\n    } else if (isObject(translation) && isSet(options.count)) {\n      translation = this.pluralize(options.count, usedScope, options);\n    }\n\n    return translation;\n  }; // This function interpolates the all variables in the given message.\n\n\n  I18n.interpolate = function (message, options) {\n    if (message == null) {\n      return message;\n    }\n\n    options = options || {};\n    var matches = message.match(this.placeholder),\n        placeholder,\n        value,\n        name,\n        regex;\n\n    if (!matches) {\n      return message;\n    }\n\n    while (matches.length) {\n      placeholder = matches.shift();\n      name = placeholder.replace(this.placeholder, \"$1\");\n\n      if (isSet(options[name])) {\n        value = options[name].toString().replace(/\\$/gm, \"_#$#_\");\n      } else if (name in options) {\n        value = this.nullPlaceholder(placeholder, message, options);\n      } else {\n        value = this.missingPlaceholder(placeholder, message, options);\n      }\n\n      regex = new RegExp(placeholder.replace(/{/gm, \"\\\\{\").replace(/}/gm, \"\\\\}\"));\n      message = message.replace(regex, value);\n    }\n\n    return message.replace(/_#\\$#_/g, \"$\");\n  }; // Pluralize the given scope using the `count` value.\n  // The pluralized translation may have other placeholders,\n  // which will be retrieved from `options`.\n\n\n  I18n.pluralize = function (count, scope, options) {\n    options = this.prepareOptions({\n      count: String(count)\n    }, options);\n    var pluralizer, result;\n    result = this.pluralizationLookup(count, scope, options);\n\n    if (typeof result.translations === \"undefined\" || result.translations == null) {\n      return this.missingTranslation(scope, options);\n    }\n\n    if (typeof result.message !== \"undefined\" && result.message != null) {\n      return this.interpolate(result.message, options);\n    } else {\n      pluralizer = this.pluralization.get(options.locale);\n      return this.missingTranslation(scope + '.' + pluralizer(count)[0], options);\n    }\n  }; // Return a missing translation message for the given parameters.\n\n\n  I18n.missingTranslation = function (scope, options) {\n    //guess intended string\n    if (this.missingBehaviour === 'guess') {\n      //get only the last portion of the scope\n      var s = scope.split('.').slice(-1)[0]; //replace underscore with space && camelcase with space and lowercase letter\n\n      return (this.missingTranslationPrefix.length > 0 ? this.missingTranslationPrefix : '') + s.replace('_', ' ').replace(/([a-z])([A-Z])/g, function (match, p1, p2) {\n        return p1 + ' ' + p2.toLowerCase();\n      });\n    }\n\n    var localeForTranslation = options != null && options.locale != null ? options.locale : this.currentLocale();\n    var fullScope = this.getFullScope(scope, options);\n    var fullScopeWithLocale = [localeForTranslation, fullScope].join(this.defaultSeparator);\n    return '[missing \"' + fullScopeWithLocale + '\" translation]';\n  }; // Return a missing placeholder message for given parameters\n\n\n  I18n.missingPlaceholder = function (placeholder, message, options) {\n    return \"[missing \" + placeholder + \" value]\";\n  };\n\n  I18n.nullPlaceholder = function () {\n    return I18n.missingPlaceholder.apply(I18n, arguments);\n  }; // Format number using localization rules.\n  // The options will be retrieved from the `number.format` scope.\n  // If this isn't present, then the following options will be used:\n  //\n  // - `precision`: `3`\n  // - `separator`: `\".\"`\n  // - `delimiter`: `\",\"`\n  // - `strip_insignificant_zeros`: `false`\n  //\n  // You can also override these options by providing the `options` argument.\n  //\n\n\n  I18n.toNumber = function (number, options) {\n    options = this.prepareOptions(options, this.lookup(\"number.format\"), NUMBER_FORMAT);\n    var negative = number < 0,\n        string = toFixed(Math.abs(number), options.precision).toString(),\n        parts = string.split(\".\"),\n        precision,\n        buffer = [],\n        formattedNumber,\n        format = options.format || \"%n\",\n        sign = negative ? \"-\" : \"\";\n    number = parts[0];\n    precision = parts[1];\n\n    while (number.length > 0) {\n      buffer.unshift(number.substr(Math.max(0, number.length - 3), 3));\n      number = number.substr(0, number.length - 3);\n    }\n\n    formattedNumber = buffer.join(options.delimiter);\n\n    if (options.strip_insignificant_zeros && precision) {\n      precision = precision.replace(/0+$/, \"\");\n    }\n\n    if (options.precision > 0 && precision) {\n      formattedNumber += options.separator + precision;\n    }\n\n    if (options.sign_first) {\n      format = \"%s\" + format;\n    } else {\n      format = format.replace(\"%n\", \"%s%n\");\n    }\n\n    formattedNumber = format.replace(\"%u\", options.unit).replace(\"%n\", formattedNumber).replace(\"%s\", sign);\n    return formattedNumber;\n  }; // Format currency with localization rules.\n  // The options will be retrieved from the `number.currency.format` and\n  // `number.format` scopes, in that order.\n  //\n  // Any missing option will be retrieved from the `I18n.toNumber` defaults and\n  // the following options:\n  //\n  // - `unit`: `\"$\"`\n  // - `precision`: `2`\n  // - `format`: `\"%u%n\"`\n  // - `delimiter`: `\",\"`\n  // - `separator`: `\".\"`\n  //\n  // You can also override these options by providing the `options` argument.\n  //\n\n\n  I18n.toCurrency = function (number, options) {\n    options = this.prepareOptions(options, this.lookup(\"number.currency.format\", options), this.lookup(\"number.format\", options), CURRENCY_FORMAT);\n    return this.toNumber(number, options);\n  }; // Localize several values.\n  // You can provide the following scopes: `currency`, `number`, or `percentage`.\n  // If you provide a scope that matches the `/^(date|time)/` regular expression\n  // then the `value` will be converted by using the `I18n.toTime` function.\n  //\n  // It will default to the value's `toString` function.\n  //\n\n\n  I18n.localize = function (scope, value, options) {\n    options || (options = {});\n\n    switch (scope) {\n      case \"currency\":\n        return this.toCurrency(value, options);\n\n      case \"number\":\n        scope = this.lookup(\"number.format\", options);\n        return this.toNumber(value, scope);\n\n      case \"percentage\":\n        return this.toPercentage(value, options);\n\n      default:\n        var localizedValue;\n\n        if (scope.match(/^(date|time)/)) {\n          localizedValue = this.toTime(scope, value, options);\n        } else {\n          localizedValue = value.toString();\n        }\n\n        return this.interpolate(localizedValue, options);\n    }\n  }; // Parse a given `date` string into a JavaScript Date object.\n  // This function is time zone aware.\n  //\n  // The following string formats are recognized:\n  //\n  //    yyyy-mm-dd\n  //    yyyy-mm-dd[ T]hh:mm::ss\n  //    yyyy-mm-dd[ T]hh:mm::ss\n  //    yyyy-mm-dd[ T]hh:mm::ssZ\n  //    yyyy-mm-dd[ T]hh:mm::ss+0000\n  //    yyyy-mm-dd[ T]hh:mm::ss+00:00\n  //    yyyy-mm-dd[ T]hh:mm::ss.123Z\n  //\n\n\n  I18n.parseDate = function (date) {\n    var matches, convertedDate, fraction; // A date input of `null` or `undefined` will be returned as-is\n\n    if (date == null) {\n      return date;\n    } // we have a date, so just return it.\n\n\n    if (_typeof(date) === \"object\") {\n      return date;\n    }\n\n    matches = date.toString().match(/(\\d{4})-(\\d{2})-(\\d{2})(?:[ T](\\d{2}):(\\d{2}):(\\d{2})([\\.,]\\d{1,3})?)?(Z|\\+00:?00)?/);\n\n    if (matches) {\n      for (var i = 1; i <= 6; i++) {\n        matches[i] = parseInt(matches[i], 10) || 0;\n      } // month starts on 0\n\n\n      matches[2] -= 1;\n      fraction = matches[7] ? 1000 * (\"0\" + matches[7]) : null;\n\n      if (matches[8]) {\n        convertedDate = new Date(Date.UTC(matches[1], matches[2], matches[3], matches[4], matches[5], matches[6], fraction));\n      } else {\n        convertedDate = new Date(matches[1], matches[2], matches[3], matches[4], matches[5], matches[6], fraction);\n      }\n    } else if (typeof date == \"number\") {\n      // UNIX timestamp\n      convertedDate = new Date();\n      convertedDate.setTime(date);\n    } else if (date.match(/([A-Z][a-z]{2}) ([A-Z][a-z]{2}) (\\d+) (\\d+:\\d+:\\d+) ([+-]\\d+) (\\d+)/)) {\n      // This format `Wed Jul 20 13:03:39 +0000 2011` is parsed by\n      // webkit/firefox, but not by IE, so we must parse it manually.\n      convertedDate = new Date();\n      convertedDate.setTime(Date.parse([RegExp.$1, RegExp.$2, RegExp.$3, RegExp.$6, RegExp.$4, RegExp.$5].join(\" \")));\n    } else if (date.match(/\\d+ \\d+:\\d+:\\d+ [+-]\\d+ \\d+/)) {\n      // a valid javascript format with timezone info\n      convertedDate = new Date();\n      convertedDate.setTime(Date.parse(date));\n    } else {\n      // an arbitrary javascript string\n      convertedDate = new Date();\n      convertedDate.setTime(Date.parse(date));\n    }\n\n    return convertedDate;\n  }; // Formats time according to the directives in the given format string.\n  // The directives begins with a percent (%) character. Any text not listed as a\n  // directive will be passed through to the output string.\n  //\n  // The accepted formats are:\n  //\n  //     %a     - The abbreviated weekday name (Sun)\n  //     %A     - The full weekday name (Sunday)\n  //     %b     - The abbreviated month name (Jan)\n  //     %B     - The full month name (January)\n  //     %c     - The preferred local date and time representation\n  //     %d     - Day of the month (01..31)\n  //     %-d    - Day of the month (1..31)\n  //     %H     - Hour of the day, 24-hour clock (00..23)\n  //     %-H/%k - Hour of the day, 24-hour clock (0..23)\n  //     %I     - Hour of the day, 12-hour clock (01..12)\n  //     %-I/%l - Hour of the day, 12-hour clock (1..12)\n  //     %m     - Month of the year (01..12)\n  //     %-m    - Month of the year (1..12)\n  //     %M     - Minute of the hour (00..59)\n  //     %-M    - Minute of the hour (0..59)\n  //     %p     - Meridian indicator (AM  or  PM)\n  //     %P     - Meridian indicator (am  or  pm)\n  //     %S     - Second of the minute (00..60)\n  //     %-S    - Second of the minute (0..60)\n  //     %w     - Day of the week (Sunday is 0, 0..6)\n  //     %y     - Year without a century (00..99)\n  //     %-y    - Year without a century (0..99)\n  //     %Y     - Year with century\n  //     %z/%Z  - Timezone offset (+0545)\n  //\n\n\n  I18n.strftime = function (date, format, options) {\n    var options = this.lookup(\"date\", options),\n        meridianOptions = I18n.meridian();\n\n    if (!options) {\n      options = {};\n    }\n\n    options = this.prepareOptions(options, DATE);\n\n    if (isNaN(date.getTime())) {\n      throw new Error('I18n.strftime() requires a valid date object, but received an invalid date.');\n    }\n\n    var weekDay = date.getDay(),\n        day = date.getDate(),\n        year = date.getFullYear(),\n        month = date.getMonth() + 1,\n        hour = date.getHours(),\n        hour12 = hour,\n        meridian = hour > 11 ? 1 : 0,\n        secs = date.getSeconds(),\n        mins = date.getMinutes(),\n        offset = date.getTimezoneOffset(),\n        absOffsetHours = Math.floor(Math.abs(offset / 60)),\n        absOffsetMinutes = Math.abs(offset) - absOffsetHours * 60,\n        timezoneoffset = (offset > 0 ? \"-\" : \"+\") + (absOffsetHours.toString().length < 2 ? \"0\" + absOffsetHours : absOffsetHours) + (absOffsetMinutes.toString().length < 2 ? \"0\" + absOffsetMinutes : absOffsetMinutes);\n\n    if (hour12 > 12) {\n      hour12 = hour12 - 12;\n    } else if (hour12 === 0) {\n      hour12 = 12;\n    }\n\n    format = format.replace(\"%a\", options.abbr_day_names[weekDay]);\n    format = format.replace(\"%A\", options.day_names[weekDay]);\n    format = format.replace(\"%b\", options.abbr_month_names[month]);\n    format = format.replace(\"%B\", options.month_names[month]);\n    format = format.replace(\"%d\", padding(day));\n    format = format.replace(\"%e\", day);\n    format = format.replace(\"%-d\", day);\n    format = format.replace(\"%H\", padding(hour));\n    format = format.replace(\"%-H\", hour);\n    format = format.replace(\"%k\", hour);\n    format = format.replace(\"%I\", padding(hour12));\n    format = format.replace(\"%-I\", hour12);\n    format = format.replace(\"%l\", hour12);\n    format = format.replace(\"%m\", padding(month));\n    format = format.replace(\"%-m\", month);\n    format = format.replace(\"%M\", padding(mins));\n    format = format.replace(\"%-M\", mins);\n    format = format.replace(\"%p\", meridianOptions[meridian]);\n    format = format.replace(\"%P\", meridianOptions[meridian].toLowerCase());\n    format = format.replace(\"%S\", padding(secs));\n    format = format.replace(\"%-S\", secs);\n    format = format.replace(\"%w\", weekDay);\n    format = format.replace(\"%y\", padding(year));\n    format = format.replace(\"%-y\", padding(year).replace(/^0+/, \"\"));\n    format = format.replace(\"%Y\", year);\n    format = format.replace(\"%z\", timezoneoffset);\n    format = format.replace(\"%Z\", timezoneoffset);\n    return format;\n  }; // Convert the given dateString into a formatted date.\n\n\n  I18n.toTime = function (scope, dateString, options) {\n    var date = this.parseDate(dateString),\n        format = this.lookup(scope, options); // A date input of `null` or `undefined` will be returned as-is\n\n    if (date == null) {\n      return date;\n    }\n\n    var date_string = date.toString();\n\n    if (date_string.match(/invalid/i)) {\n      return date_string;\n    }\n\n    if (!format) {\n      return date_string;\n    }\n\n    return this.strftime(date, format, options);\n  }; // Convert a number into a formatted percentage value.\n\n\n  I18n.toPercentage = function (number, options) {\n    options = this.prepareOptions(options, this.lookup(\"number.percentage.format\", options), this.lookup(\"number.format\", options), PERCENTAGE_FORMAT);\n    return this.toNumber(number, options);\n  }; // Convert a number into a readable size representation.\n\n\n  I18n.toHumanSize = function (number, options) {\n    var kb = 1024,\n        size = number,\n        iterations = 0,\n        unit,\n        precision;\n\n    while (size >= kb && iterations < 4) {\n      size = size / kb;\n      iterations += 1;\n    }\n\n    if (iterations === 0) {\n      unit = this.t(\"number.human.storage_units.units.byte\", {\n        count: size\n      });\n      precision = 0;\n    } else {\n      unit = this.t(\"number.human.storage_units.units.\" + SIZE_UNITS[iterations]);\n      precision = size - Math.floor(size) === 0 ? 0 : 1;\n    }\n\n    options = this.prepareOptions(options, {\n      unit: unit,\n      precision: precision,\n      format: \"%n%u\",\n      delimiter: \"\"\n    });\n    return this.toNumber(size, options);\n  };\n\n  I18n.getFullScope = function (scope, options) {\n    options = options || {}; // Deal with the scope as an array.\n\n    if (isArray(scope)) {\n      scope = scope.join(this.defaultSeparator);\n    } // Deal with the scope option provided through the second argument.\n    //\n    //    I18n.t('hello', {scope: 'greetings'});\n    //\n\n\n    if (options.scope) {\n      scope = [options.scope, scope].join(this.defaultSeparator);\n    }\n\n    return scope;\n  };\n  /**\n   * Merge obj1 with obj2 (shallow merge), without modifying inputs\n   * @param {Object} obj1\n   * @param {Object} obj2\n   * @returns {Object} Merged values of obj1 and obj2\n   *\n   * In order to support ES3, `Object.prototype.hasOwnProperty.call` is used\n   * Idea is from:\n   * https://stackoverflow.com/questions/8157700/object-has-no-hasownproperty-method-i-e-its-undefined-ie8\n   */\n\n\n  I18n.extend = function (obj1, obj2) {\n    if (typeof obj1 === \"undefined\" && typeof obj2 === \"undefined\") {\n      return {};\n    }\n\n    return merge(obj1, obj2);\n  }; // Set aliases, so we can save some typing.\n\n\n  I18n.t = I18n.translate.bind(I18n);\n  I18n.l = I18n.localize.bind(I18n);\n  I18n.p = I18n.pluralize.bind(I18n);\n  return I18n;\n});","map":null,"metadata":{},"sourceType":"module"}